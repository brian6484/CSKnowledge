{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "47KZRhT9kNqIeO2Vuj__s",
      "type": "rectangle",
      "x": -658.5700794655036,
      "y": -10605.571100969077,
      "width": 895.4329574627636,
      "height": 773.8449324277244,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aq",
      "roundness": {
        "type": 3
      },
      "seed": 1331882121,
      "version": 58,
      "versionNonce": 1424869353,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1760922867166,
      "link": null,
      "locked": false
    },
    {
      "id": "97yCKF7LuiopcbbmFIKYE",
      "type": "text",
      "x": -622.4913705507154,
      "y": -10564.663015236816,
      "width": 831.95947265625,
      "height": 375,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "ar",
      "roundness": null,
      "seed": 1459186023,
      "version": 848,
      "versionNonce": 1702606953,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1760923260465,
      "link": null,
      "locked": false,
      "text": "scenario: design multi region failover system for e-commerce\nclarifying questions: \n1) so i assume the e commerce platform system has already been designed? and i just\nadd functionalities to tackle this failover? no, design the entire system from scratch\n2) u mentioned its regional failure but can cross-regional failure also occur? yes\nits possible. What happens if us-east cant talk to eu? How to prevent split-brain\nwhere **both regions think they are primary**?\n3) what if payment fails midway during a regional failure? do we have to handle that?\nyes. It should be idempotent\n4) 400 bytes/payment, 3Kb/product\n\nfunctional req:\ndesign e-commerce platform from scratch with multi-region failover\nhandle transactions that happen during a regional failure\nhandle cross-regional failure",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "scenario: design multi region failover system for e-commerce\nclarifying questions: \n1) so i assume the e commerce platform system has already been designed? and i just\nadd functionalities to tackle this failover? no, design the entire system from scratch\n2) u mentioned its regional failure but can cross-regional failure also occur? yes\nits possible. What happens if us-east cant talk to eu? How to prevent split-brain\nwhere **both regions think they are primary**?\n3) what if payment fails midway during a regional failure? do we have to handle that?\nyes. It should be idempotent\n4) 400 bytes/payment, 3Kb/product\n\nfunctional req:\ndesign e-commerce platform from scratch with multi-region failover\nhandle transactions that happen during a regional failure\nhandle cross-regional failure",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "OJZyPV7MH5W5IsuR8sfbd",
      "type": "rectangle",
      "x": 285.72536912185296,
      "y": -10594.207706493966,
      "width": 1062.4743436593149,
      "height": 754.5272192558514,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "as",
      "roundness": {
        "type": 3
      },
      "seed": 341144105,
      "version": 78,
      "versionNonce": 1312540233,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1760923367974,
      "link": null,
      "locked": false
    },
    {
      "id": "0QsniXpO5-IcQHSlKHi9c",
      "type": "text",
      "x": 321.37003289921506,
      "y": -10570.638678744806,
      "width": 1000.4592895507812,
      "height": 475,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "at",
      "roundness": null,
      "seed": 1171233031,
      "version": 875,
      "versionNonce": 666226759,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1760925170164,
      "link": null,
      "locked": false,
      "text": "non-functional req:\ncalc:\n100M users, 10M products, 50k orders/sec\nproduct data: \n10M * 3K = 30G of memory\norder data:\n50k orders * 400bytes = 20000k = 20Mb/s\n\ncap theorem:\nproduct can be AP with eventual consistency but payment and inventory service has to be CP because\nwe must have isolated nodes to sync and prevent duplicate/invalid payment requests. If we have AP \nthen we could accept a payment or order but later when parittion is solved, we might have to cancel\nthe order cuz of insufficient inventory or invalid payment \n\n<30s RTO with high availability but for payment service the RPO (recovery point objective) which\ntells how much data we can afford to lose should be 0\n\nregulatory: EU data must stay in EU, payment data encryption at rest/transit\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "non-functional req:\ncalc:\n100M users, 10M products, 50k orders/sec\nproduct data: \n10M * 3K = 30G of memory\norder data:\n50k orders * 400bytes = 20000k = 20Mb/s\n\ncap theorem:\nproduct can be AP with eventual consistency but payment and inventory service has to be CP because\nwe must have isolated nodes to sync and prevent duplicate/invalid payment requests. If we have AP \nthen we could accept a payment or order but later when parittion is solved, we might have to cancel\nthe order cuz of insufficient inventory or invalid payment \n\n<30s RTO with high availability but for payment service the RPO (recovery point objective) which\ntells how much data we can afford to lose should be 0\n\nregulatory: EU data must stay in EU, payment data encryption at rest/transit\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "FiIQ-JRZljd-6mbFrvEbC",
      "type": "rectangle",
      "x": -652.4308383638471,
      "y": -9772.724364462358,
      "width": 1119.3793166064897,
      "height": 1497.4807841493346,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "au",
      "roundness": {
        "type": 3
      },
      "seed": 524301513,
      "version": 242,
      "versionNonce": 781185095,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1760926509401,
      "link": null,
      "locked": false
    },
    {
      "id": "eL7_gs1Tv2dLV1mMnuInc",
      "type": "text",
      "x": -631.5357729697463,
      "y": -9751.82925162278,
      "width": 1245.6190185546875,
      "height": 2625,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "av",
      "roundness": null,
      "seed": 990222023,
      "version": 6030,
      "versionNonce": 1836887817,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1760929188861,
      "link": null,
      "locked": false,
      "text": "my design:\nclient request -> LB (to dist traffic evenly) -> product service (list products and details) -> product db\n(its not bottleneck here cuz only 30Gb so can just use postgres but optimise with Redis cache for\ntop popular products or user's starred/interest products)\n\nLB can also -> payment service(for actual payment) -> kafka queue(topic:payment and to increase \nreliability to store messages when payment service goes down so that we can try when service is up)\n-> worker nodes can store to DB \n\npayment DB has to be CP and handle heavy write throughput. We can use HBase for CP but Idk Hbase\nso I will choose Cassandra for AP and adjust the consistency level. Cass is decentralised and can evenly\ndistribute traffic via parition key(user_id) and clustering key(payment_id), which will sort data\nbased on these keys. Using parition key of user_id prevents cross-shard query when we search for user's\norder or payment details cuz can just query 1 shard\n\nfor regional failover, we can choose cross-region nodes in Cassandra's consistent hash ring and set quorum\nconsensus to be highly consistent so that replication is done on those cross region nodes before processing\nthe payment. But if the coordinator node that was handling this payment fails, then it can failover to other\nnodes in the ring to complete that transaction. [gpt improvement] Also mention RF of 3. So if 3 regions \nwith RF=3, theres 9 nods and for quorum write = 5/9 nodes must ack. If US fails theres 6 nodes remaining so 6>5 system still\nworks. If client sends payment write to node A (coordinator) and it fails mid-write, client library detects\ntimeout and hits node-b(new coordinator) and checks if this payment has succeeded and uses idempotent\nkey to prevent duplciates. Client side retry logic with expon. backoff can also tried. \n\ngpt correction:\nso the partition key strat and cross-region replication with quorum for Cass is correct. but kafka for \npayment and Cassandra choice for payment db is wrong\n1) But using cass for payment is wrong cuz u cant truly make it as CP. There is no ACID transaction\nacross paritions. \n\nfor example in postgres, u might have transaction of 2 updates of + and - funds and insert and commit. \nEither all succeed or all rollback but in Cassandra, the 2 updates and 1 insert are all SEPARATE operations\nand not atomic tgt.\n\nI actually didnt choose Postgres cuz i thought it cant handle 20Mb/s writes = 1.7Tb/day but cockroach\nwith 5 node cluster or postgres with syncrhonous replication can also handle with a bit of latency. \nu can optimise via batch writes, or write-ahead log(wal) tuning \nU can\nhave primary postgres in US and read only replicas in EU and ASIA. \n\nfailover srat:\n1) primary region fails - health check fail and consensus service(etcd) detects primary down and triggers \nautomatic failover. Can select new primary from replicas. If transaction is committed before crash, \nits replicated to replicas so its safe but if uncommited it is lost. In doubt can use idempotency key.\n\n2) network partition between regions - split brain problem and both replicas think they should become the\nprimary. Sol is quorum based failover (2/3 regions) actually this still fails cuz\n\nif US is solated, and EU + ASIA can communicate so both replicas have 2/3 consensus condition. Instead we \nshould use a distributed consensus (raft/paxos) or a pre designated priority (priority config where US is\nprimary, EU is first, Asia is second and only promotes to Next in priority order)\n\n2) using kafka queue for payment is dangerous. It creates async processing where payment succeeds.\nGPT said user has to wait for worker node to consume and complete that transaction. \nBut i thought the point of using kafka was ability to return to user immediately. Actually we cannot return \nwith success code cuz we havent completed transaction yet but a \"pending transaction is being processed, \nplease wait\" response. So while kafka is fine for post-payment events like notif or analytics, payment should be\nsynchronous with 2PC or saga pattern.\n\n2PC: (synchronous and blocking protocol)\nCoordinator (Order service) orcehstrats\nphase 1: prepare and ask if everyone is ready\ncoordinator -> ask payment service if u can charge $100 -> payment service ask stripe to reserve $100 and\nstripe and apyment responds with OK READY\ncoordinator -> asks inventory service if u can reserve 1 item -> OK response back\n\nphase 2: commit\ncoordinator node demands payment and inventory and order DB to execute so all succeed tgt. \n\nphase 2: rollback\nif coordinator node sees that if inventory service failed, we abort the entire process so asks payment and\ninventory to rollback\n\nSaga pattern: (asynchronous) i dont rly get \nit breaks a large transaction into a sequence of local transactions and coordinated thru events/orchestrator\nand if something fails, **compensating transactions** undo previous steps\n\nUser Request\n    ↓\nAPI Gateway\n    ↓\nOrder Service (Saga Orchestrator)\n    ↓\n    ├─→ Payment Service (sync) → Stripe API\n    │   ✅ Charge succeeds → Continue\n    │   ❌ Charge fails → Return error immediately\n    ↓\n    ├─→ Inventory Service (sync) → Check/reserve stock\n    │   ✅ Reserved → Continue\n    │   ❌ Out of stock → Refund payment, return error\n    ↓\n    ├─→ Order DB (sync) → Create order record\n    │   ✅ Created → Success! Return order_id to user\n    │   ❌ DB error → Refund payment, release inventory\n    ↓\n    └─→ Kafka (async) → Publish \"order.created\" event\n        → Email Service sends confirmation\n        → Analytics Service logs event\n        → Warehouse Service prepares shipment \n\nif anything fails along the way, each rollbakc step is a **compensentating transaction**, not a \nliteral rollback in DB.\n\n3) i said if cooridinator node fails, failover to other nodes in the ring. But how does client know to\nretry to diff region? (need global LB like route 53/cloudflare)",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "my design:\nclient request -> LB (to dist traffic evenly) -> product service (list products and details) -> product db\n(its not bottleneck here cuz only 30Gb so can just use postgres but optimise with Redis cache for\ntop popular products or user's starred/interest products)\n\nLB can also -> payment service(for actual payment) -> kafka queue(topic:payment and to increase \nreliability to store messages when payment service goes down so that we can try when service is up)\n-> worker nodes can store to DB \n\npayment DB has to be CP and handle heavy write throughput. We can use HBase for CP but Idk Hbase\nso I will choose Cassandra for AP and adjust the consistency level. Cass is decentralised and can evenly\ndistribute traffic via parition key(user_id) and clustering key(payment_id), which will sort data\nbased on these keys. Using parition key of user_id prevents cross-shard query when we search for user's\norder or payment details cuz can just query 1 shard\n\nfor regional failover, we can choose cross-region nodes in Cassandra's consistent hash ring and set quorum\nconsensus to be highly consistent so that replication is done on those cross region nodes before processing\nthe payment. But if the coordinator node that was handling this payment fails, then it can failover to other\nnodes in the ring to complete that transaction. [gpt improvement] Also mention RF of 3. So if 3 regions \nwith RF=3, theres 9 nods and for quorum write = 5/9 nodes must ack. If US fails theres 6 nodes remaining so 6>5 system still\nworks. If client sends payment write to node A (coordinator) and it fails mid-write, client library detects\ntimeout and hits node-b(new coordinator) and checks if this payment has succeeded and uses idempotent\nkey to prevent duplciates. Client side retry logic with expon. backoff can also tried. \n\ngpt correction:\nso the partition key strat and cross-region replication with quorum for Cass is correct. but kafka for \npayment and Cassandra choice for payment db is wrong\n1) But using cass for payment is wrong cuz u cant truly make it as CP. There is no ACID transaction\nacross paritions. \n\nfor example in postgres, u might have transaction of 2 updates of + and - funds and insert and commit. \nEither all succeed or all rollback but in Cassandra, the 2 updates and 1 insert are all SEPARATE operations\nand not atomic tgt.\n\nI actually didnt choose Postgres cuz i thought it cant handle 20Mb/s writes = 1.7Tb/day but cockroach\nwith 5 node cluster or postgres with syncrhonous replication can also handle with a bit of latency. \nu can optimise via batch writes, or write-ahead log(wal) tuning \nU can\nhave primary postgres in US and read only replicas in EU and ASIA. \n\nfailover srat:\n1) primary region fails - health check fail and consensus service(etcd) detects primary down and triggers \nautomatic failover. Can select new primary from replicas. If transaction is committed before crash, \nits replicated to replicas so its safe but if uncommited it is lost. In doubt can use idempotency key.\n\n2) network partition between regions - split brain problem and both replicas think they should become the\nprimary. Sol is quorum based failover (2/3 regions) actually this still fails cuz\n\nif US is solated, and EU + ASIA can communicate so both replicas have 2/3 consensus condition. Instead we \nshould use a distributed consensus (raft/paxos) or a pre designated priority (priority config where US is\nprimary, EU is first, Asia is second and only promotes to Next in priority order)\n\n2) using kafka queue for payment is dangerous. It creates async processing where payment succeeds.\nGPT said user has to wait for worker node to consume and complete that transaction. \nBut i thought the point of using kafka was ability to return to user immediately. Actually we cannot return \nwith success code cuz we havent completed transaction yet but a \"pending transaction is being processed, \nplease wait\" response. So while kafka is fine for post-payment events like notif or analytics, payment should be\nsynchronous with 2PC or saga pattern.\n\n2PC: (synchronous and blocking protocol)\nCoordinator (Order service) orcehstrats\nphase 1: prepare and ask if everyone is ready\ncoordinator -> ask payment service if u can charge $100 -> payment service ask stripe to reserve $100 and\nstripe and apyment responds with OK READY\ncoordinator -> asks inventory service if u can reserve 1 item -> OK response back\n\nphase 2: commit\ncoordinator node demands payment and inventory and order DB to execute so all succeed tgt. \n\nphase 2: rollback\nif coordinator node sees that if inventory service failed, we abort the entire process so asks payment and\ninventory to rollback\n\nSaga pattern: (asynchronous) i dont rly get \nit breaks a large transaction into a sequence of local transactions and coordinated thru events/orchestrator\nand if something fails, **compensating transactions** undo previous steps\n\nUser Request\n    ↓\nAPI Gateway\n    ↓\nOrder Service (Saga Orchestrator)\n    ↓\n    ├─→ Payment Service (sync) → Stripe API\n    │   ✅ Charge succeeds → Continue\n    │   ❌ Charge fails → Return error immediately\n    ↓\n    ├─→ Inventory Service (sync) → Check/reserve stock\n    │   ✅ Reserved → Continue\n    │   ❌ Out of stock → Refund payment, return error\n    ↓\n    ├─→ Order DB (sync) → Create order record\n    │   ✅ Created → Success! Return order_id to user\n    │   ❌ DB error → Refund payment, release inventory\n    ↓\n    └─→ Kafka (async) → Publish \"order.created\" event\n        → Email Service sends confirmation\n        → Analytics Service logs event\n        → Warehouse Service prepares shipment \n\nif anything fails along the way, each rollbakc step is a **compensentating transaction**, not a \nliteral rollback in DB.\n\n3) i said if cooridinator node fails, failover to other nodes in the ring. But how does client know to\nretry to diff region? (need global LB like route 53/cloudflare)",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff",
    "lockedMultiSelections": {}
  },
  "files": {}
}